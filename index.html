<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Study Schedule Generator</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for the app */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8; /* Light blue-gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better scrolling */
            min-height: 100vh;
            padding: 2rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #ffffff;
            padding: 2.5rem;
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Softer shadow */
            max-width: 900px; /* Increased max-width */
            width: 100%;
        }
        input[type="date"],
        input[type="time"],
        input[type="text"],
        input[type="number"],
        select {
            border: 1px solid #cbd5e1; /* Light gray border */
            padding: 0.75rem 1rem;
            border-radius: 0.75rem; /* Rounded input fields */
            width: 100%;
            box-sizing: border-box;
            font-size: 1rem;
            color: #334155; /* Darker text */
            transition: border-color 0.2s ease-in-out;
        }
        input[type="date"]:focus,
        input[type="time"]:focus,
        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #6366f1; /* Indigo focus color */
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.2); /* Light focus shadow */
        }
        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            transform: translateY(-1px);
        }
        .btn-primary {
            background-color: #6366f1; /* Indigo */
            color: white;
        }
        .btn-primary:hover {
            background-color: #4f46e5; /* Darker indigo */
        }
        .btn-secondary {
            background-color: #e2e8f0; /* Light gray */
            color: #334155;
        }
        .btn-secondary:hover {
            background-color: #cbd5e1; /* Darker light gray */
        }
        .schedule-output {
            background-color: #f8fafc; /* Very light blue-gray */
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-top: 2rem;
            max-height: 600px; /* Fixed height for scrolling */
            overflow-y: auto; /* Enable vertical scrolling */
        }
        .schedule-day {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px dashed #e2e8f0;
        }
        .schedule-day:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        .schedule-entry {
            background-color: #eff6ff; /* Lighter blue */
            border-left: 4px solid #3b82f6; /* Blue accent */
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .schedule-entry.break {
            background-color: #fef3c7; /* Light yellow for breaks */
            border-left: 4px solid #f59e0b; /* Orange accent */
            color: #92400e; /* Darker orange text */
            padding-top: 0.2rem; /* Reduced padding for breaks */
            padding-bottom: 0.2rem; /* Reduced padding for breaks */
            text-align: center; /* Center "Break" text */
        }
        .schedule-entry.break p:first-child {
            margin-bottom: 0; /* Remove margin from break text */
        }
        .schedule-entry.break p:last-child {
            display: none; /* Hide time for breaks */
        }
        .subject-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: #f8fafc;
            border: 1px solid #e2e8f0;
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            margin-bottom: 0.75rem;
        }
        .subject-item:last-child {
            margin-bottom: 0;
        }
        .error-message {
            background-color: #fee2e2; /* Light red */
            color: #ef4444; /* Red text */
            padding: 1rem;
            border-radius: 0.75rem;
            margin-bottom: 1.5rem;
            border: 1px solid #fca5a5;
            display: none; /* Hidden by default */
        }
        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            .container {
                padding: 1.5rem;
            }
            .grid-cols-2 {
                grid-template-columns: 1fr; /* Stack columns on small screens */
            }
            .flex-col-reverse-sm {
                flex-direction: column-reverse; /* Stack subject inputs on small screens */
            }
            /* Adjust grid for daily time inputs on smaller screens */
            .daily-time-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
        }
    </style>
    <link rel="manifest" href="./manifest.json">
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./service-worker.js')
        .then(registration => {
          console.log('ServiceWorker registered: ', registration);
        })
        .catch(registrationError => {
          console.log('ServiceWorker registration failed: ', registrationError);
        });
    });
  }
</script>
</head>
<body class="bg-gray-100 p-8">
    <div class="container mx-auto p-8 bg-white rounded-xl shadow-lg">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-8">Soham's Study Schedule Generator</h1>

        <div id="error-message" class="error-message"></div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
            <!-- Date Inputs -->
            <div>
                <label for="startDate" class="block text-gray-700 text-sm font-semibold mb-2">Start Date:</label>
                <input type="date" id="startDate" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <div>
                <label for="endDate" class="block text-gray-700 text-sm font-semibold mb-2">End Date:</label>
                <input type="date" id="endDate" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
            </div>
        </div>

        <!-- Time Inputs per Day Type -->
        <div class="mb-8">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Daily Study Time:</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                <!-- Weekdays -->
                <div>
                    <label class="block text-gray-700 text-sm font-semibold mb-2">Weekdays (Mon - Fri):</label>
                    <input type="time" id="weekdayStartTime" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 mb-2">
                    <input type="time" id="weekdayEndTime" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <!-- Weekends -->
                <div>
                    <label class="block text-gray-700 text-sm font-semibold mb-2">Weekends (Sat - Sun):</label>
                    <input type="time" id="weekendStartTime" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500 mb-2">
                    <input type="time" id="weekendEndTime" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                </div>
            </div>
        </div>

        <!-- Subjects Input -->
        <div class="mb-8">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Subjects with Priority:</h2>
            <div class="flex flex-col md:flex-row gap-4 mb-4 items-end flex-col-reverse-sm">
                <div class="flex-grow">
                    <label for="subjectName" class="block text-gray-700 text-sm font-semibold mb-2">Subject Name:</label>
                    <input type="text" id="subjectName" placeholder="e.g., Mathematics" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                </div>
                <div>
                    <label for="subjectPriority" class="block text-gray-700 text-sm font-semibold mb-2">Priority (1-5, 1=Highest):</label>
                    <select id="subjectPriority" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-indigo-500 focus:border-indigo-500">
                        <option value="1">1 (Highest)</option>
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4">4</option>
                        <option value="5">5 (Lowest)</option>
                    </select>
                </div>
                <button id="addSubjectBtn" class="btn-secondary whitespace-nowrap px-6 py-3">Add Subject</button>
            </div>
            <div id="subjectsList" class="space-y-3">
                <!-- Subjects will be listed here -->
            </div>
        </div>

        <!-- Generate Button -->
        <div class="text-center mb-8 flex flex-col sm:flex-row justify-center gap-4">
            <button id="generateScheduleBtn" class="btn-primary px-8 py-4 text-xl">Generate Schedule</button>
            <button id="downloadScheduleBtn" class="btn-secondary px-8 py-4 text-xl hidden">Download Schedule</button>
        </div>

        <!-- Schedule Output -->
        <div id="scheduleOutput" class="schedule-output hidden">
            <h2 class="text-2xl font-bold text-gray-800 mb-6 text-center">Generated Study Schedule</h2>
            <div id="scheduleContent">
                <!-- Schedule will be displayed here -->
            </div>
        </div>
    </div>

    <script>
        // Get DOM elements
        const startDateInput = document.getElementById('startDate');
        const endDateInput = document.getElementById('endDate');

        // Daily time inputs for weekdays and weekends
        const weekdayStartTimeInput = document.getElementById('weekdayStartTime');
        const weekdayEndTimeInput = document.getElementById('weekdayEndTime');
        const weekendStartTimeInput = document.getElementById('weekendStartTime');
        const weekendEndTimeInput = document.getElementById('weekendEndTime');

        const subjectNameInput = document.getElementById('subjectName');
        const subjectPrioritySelect = document.getElementById('subjectPriority');
        const addSubjectBtn = document.getElementById('addSubjectBtn');
        const subjectsListDiv = document.getElementById('subjectsList');
        const generateScheduleBtn = document.getElementById('generateScheduleBtn');
        const downloadScheduleBtn = document.getElementById('downloadScheduleBtn'); // New button
        const scheduleOutputDiv = document.getElementById('scheduleOutput');
        const scheduleContentDiv = document.getElementById('scheduleContent');
        const errorMessageDiv = document.getElementById('error-message');

        // Array to store subjects
        let subjects = [];
        // Store the last generated schedule data for download
        let lastGeneratedSchedule = [];

        // Function to display error messages
        function showErrorMessage(message) {
            errorMessageDiv.textContent = message;
            errorMessageDiv.style.display = 'block';
        }

        // Function to hide error messages
        function hideErrorMessage() {
            errorMessageDiv.style.display = 'none';
            errorMessageDiv.textContent = '';
        }

        // Function to render subjects in the list
        function renderSubjects() {
            subjectsListDiv.innerHTML = ''; // Clear existing list
            if (subjects.length === 0) {
                subjectsListDiv.innerHTML = '<p class="text-gray-500 text-center">No subjects added yet.</p>';
                return;
            }
            subjects.forEach((subject, index) => {
                const subjectItem = document.createElement('div');
                subjectItem.className = 'subject-item';
                subjectItem.innerHTML = `
                    <span class="text-gray-700 font-medium">${subject.name}</span>
                    <span class="text-gray-600">Priority: ${subject.priority}</span>
                    <button data-index="${index}" class="remove-subject-btn text-red-600 hover:text-red-800 font-semibold text-sm">Remove</button>
                `;
                subjectsListDiv.appendChild(subjectItem);
            });

            // Add event listeners to remove buttons
            document.querySelectorAll('.remove-subject-btn').forEach(button => {
                button.addEventListener('click', (event) => {
                    const indexToRemove = parseInt(event.target.dataset.index);
                    subjects.splice(indexToRemove, 1); // Remove subject from array
                    renderSubjects(); // Re-render the list
                });
            });
        }

        // Add Subject button click handler
        addSubjectBtn.addEventListener('click', () => {
            hideErrorMessage();
            const name = subjectNameInput.value.trim();
            const priority = parseInt(subjectPrioritySelect.value);

            if (name === '') {
                showErrorMessage('Subject name cannot be empty.');
                return;
            }
            if (subjects.some(s => s.name.toLowerCase() === name.toLowerCase())) {
                showErrorMessage('Subject with this name already exists.');
                return;
            }

            subjects.push({ name, priority });
            subjectNameInput.value = ''; // Clear input field
            subjectPrioritySelect.value = '1'; // Reset priority
            renderSubjects(); // Update the displayed list
        });

        // Helper function to parse time string (HH:MM) into minutes from midnight
        function parseTime(timeStr) {
            if (!timeStr) return null; // Handle empty time string
            const [hours, minutes] = timeStr.split(':').map(Number);
            return hours * 60 + minutes;
        }

        // Helper function to format minutes from midnight back to HH:MM string
        function formatTime(minutes) {
            const hours = Math.floor(minutes / 60);
            const mins = minutes % 60;
            return `${String(hours).padStart(2, '0')}:${String(mins).padStart(2, '0')}`;
        }

        // Helper function to format date to YYYY-MM-DD
        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Helper function to get day name
        function getDayName(date) {
            const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            return days[date.getDay()];
        }

        // New helper function to merge consecutive study blocks for the same subject
        function mergeConsecutiveSubjects(scheduleArray) {
            if (scheduleArray.length === 0) return [];

            const mergedSchedule = [];
            let currentMergedEntry = null;

            scheduleArray.forEach(entry => {
                if (entry.isBreak) {
                    // If it's a break, add any existing merged entry and then the break itself
                    if (currentMergedEntry) {
                        mergedSchedule.push(currentMergedEntry);
                        currentMergedEntry = null;
                    }
                    mergedSchedule.push(entry);
                } else {
                    // If it's a study entry
                    if (currentMergedEntry && currentMergedEntry.subject === entry.subject &&
                        parseTime(currentMergedEntry.endTime) === parseTime(entry.startTime)) {
                        // If current entry is same subject and immediately follows previous, merge
                        currentMergedEntry.endTime = entry.endTime;
                    } else {
                        // Otherwise, push the previous merged entry (if any) and start a new one
                        if (currentMergedEntry) {
                            mergedSchedule.push(currentMergedEntry);
                        }
                        currentMergedEntry = { ...entry }; // Create a copy
                    }
                }
            });

            // Push the last merged entry if it exists
            if (currentMergedEntry) {
                mergedSchedule.push(currentMergedEntry);
            }

            return mergedSchedule;
        }


        // Generate Schedule button click handler
        generateScheduleBtn.addEventListener('click', () => {
            hideErrorMessage(); // Clear previous errors
            downloadScheduleBtn.classList.add('hidden'); // Hide download button until new schedule is generated

            const startDate = new Date(startDateInput.value);
            const endDate = new Date(endDateInput.value);

            // --- Input Validation ---
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                showErrorMessage('Please select valid start and end dates.');
                return;
            }
            if (startDate > endDate) {
                showErrorMessage('Start date cannot be after end date.');
                return;
            }

            if (subjects.length === 0) {
                showErrorMessage('Please add at least one subject to generate a schedule.');
                return;
            }

            // Validate weekday times
            const weekdayStartTime = weekdayStartTimeInput.value;
            const weekdayEndTime = weekdayEndTimeInput.value;
            const parsedWeekdayStartTime = parseTime(weekdayStartTime);
            const parsedWeekdayEndTime = parseTime(weekdayEndTime);

            if (weekdayStartTime && weekdayEndTime && parsedWeekdayStartTime >= parsedWeekdayEndTime) {
                showErrorMessage('Weekdays: End time must be after start time.');
                return;
            }

            // Validate weekend times
            const weekendStartTime = weekendStartTimeInput.value;
            const weekendEndTime = weekendEndTimeInput.value;
            const parsedWeekendStartTime = parseTime(weekendStartTime);
            const parsedWeekendEndTime = parseTime(weekendEndTime);

            if (weekendStartTime && weekendEndTime && parsedWeekendStartTime >= parsedWeekendEndTime) {
                showErrorMessage('Weekends: End time must be after start time.');
                return;
            }

            // Ensure at least one set of times is provided
            if ((!weekdayStartTime || !weekdayEndTime) && (!weekendStartTime || !weekendEndTime)) {
                showErrorMessage('Please enter study times for at least weekdays or weekends.');
                return;
            }

            // Initialize P2 skip status for all P2 subjects (false means eligible for today)
            // This map will be updated at the end of each day's scheduling
            let p2SkipStatus = new Map();
            subjects.filter(s => s.priority === 2).forEach(s => p2SkipStatus.set(s.name, false));

            // --- Scheduling Logic ---
            const schedule = [];
            const studyBlockDuration = 45; // minutes per study block
            const breakDuration = 10; // minutes break after each 2-hour stretch (3 study blocks)
            const blocksPerStretch = 3; // Number of 45-min blocks before a break

            let currentDay = new Date(startDate);
            while (currentDay <= endDate) {
                const dayOfWeek = currentDay.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday

                let currentDayStartTimeStr = null;
                let currentDayEndTimeStr = null;

                // Determine which time block to use (weekday or weekend)
                if (dayOfWeek >= 1 && dayOfWeek <= 5) { // Monday to Friday
                    currentDayStartTimeStr = weekdayStartTimeInput.value;
                    currentDayEndTimeStr = weekdayEndTimeInput.value;
                } else { // Saturday (6) or Sunday (0)
                    currentDayStartTimeStr = weekendStartTimeInput.value;
                    currentDayEndTimeStr = weekendEndTimeInput.value;
                }

                let dailyScheduleEntries = []; // Temporary array for this day's schedule
                let currentDayStartTime = parseTime(currentDayStartTimeStr);
                let currentDayEndTime = parseTime(currentDayEndTimeStr);

                // Initialize nextDayP2SkipStatus for the current iteration
                // This ensures it's always defined, even if no study time is available for the day.
                let nextDayP2SkipStatus = new Map(p2SkipStatus);

                // Only schedule if time is set for this specific day type and valid
                if (currentDayStartTimeStr && currentDayEndTimeStr && currentDayStartTime !== null && currentDayEndTime !== null && currentDayStartTime < currentDayEndTime) {
                    // Create an array of all potential 45-min study slots and break slots for the day
                    let allPotentialSlots = [];
                    let tempTime = currentDayStartTime;
                    let blocksInCurrentStretch = 0;

                    while (tempTime + studyBlockDuration <= currentDayEndTime) {
                        allPotentialSlots.push({
                            startTime: tempTime,
                            endTime: tempTime + studyBlockDuration,
                            type: 'study'
                        });
                        tempTime += studyBlockDuration;
                        blocksInCurrentStretch++;

                        if (blocksInCurrentStretch === blocksPerStretch) { // After 3 study blocks, add a break
                            if (tempTime + breakDuration <= currentDayEndTime) {
                                allPotentialSlots.push({
                                    startTime: tempTime,
                                    endTime: tempTime + breakDuration,
                                    type: 'break'
                                });
                                tempTime += breakDuration;
                            }
                            blocksInCurrentStretch = 0; // Reset for the next stretch
                        }
                    }

                    let assignedSlots = new Array(allPotentialSlots.length).fill(false); // To track assigned slots

                    // Separate subjects by priority for easier management
                    const p1Subjects = subjects.filter(s => s.priority === 1).sort((a, b) => a.name.localeCompare(b.name));
                    const p2Subjects = subjects.filter(s => s.priority === 2).sort((a, b) => a.name.localeCompare(b.name));
                    const p3Subjects = subjects.filter(s => s.priority === 3).sort((a, b) => a.name.localeCompare(b.name));
                    const p4Subjects = subjects.filter(s => s.priority === 4).sort((a, b) => a.name.localeCompare(b.name));
                    const p5Subjects = subjects.filter(s => s.priority === 5).sort((a, b) => a.name.localeCompare(b.name));

                    // P2 alternative day logic: determine eligible P2 subjects for today
                    let eligibleP2ForToday = [];
                    // nextDayP2SkipStatus is already initialized above as a copy of p2SkipStatus

                    p2Subjects.forEach(p2Subject => {
                        if (!p2SkipStatus.get(p2Subject.name)) { // If not marked to skip today (i.e., eligible)
                            eligibleP2ForToday.push(p2Subject);
                            nextDayP2SkipStatus.set(p2Subject.name, true); // Mark to skip tomorrow
                        } else { // Was skipped yesterday, so mark as eligible tomorrow
                            nextDayP2SkipStatus.set(p2Subject.name, false);
                        }
                    });
                    // Shuffle eligible P2 subjects to distribute them fairly
                    for (let i = eligibleP2ForToday.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [eligibleP2ForToday[i], eligibleP2ForToday[j]] = [eligibleP2ForToday[j], eligibleP2ForToday[i]];
                    }


                    // --- Assignment Phase ---

                    // 1. Assign Priority 1 Subjects (min 1.5 hrs = 2 blocks)
                    const p1BlocksNeeded = 2; // 2 blocks = 90 minutes
                    p1Subjects.forEach(p1Subject => {
                        let blocksAssignedForP1 = 0;
                        for (let i = 0; i < allPotentialSlots.length; i++) {
                            if (allPotentialSlots[i].type === 'study' && !assignedSlots[i]) {
                                // Try to find 2 consecutive study blocks
                                if (i + 1 < allPotentialSlots.length && allPotentialSlots[i+1].type === 'study' && !assignedSlots[i+1]) {
                                    dailyScheduleEntries.push({
                                        subject: p1Subject.name,
                                        startTime: formatTime(allPotentialSlots[i].startTime),
                                        endTime: formatTime(allPotentialSlots[i].endTime)
                                    });
                                    assignedSlots[i] = true;
                                    blocksAssignedForP1++;

                                    dailyScheduleEntries.push({
                                        subject: p1Subject.name,
                                        startTime: formatTime(allPotentialSlots[i+1].startTime),
                                        endTime: formatTime(allPotentialSlots[i+1].endTime)
                                    });
                                    assignedSlots[i+1] = true;
                                    blocksAssignedForP1++;
                                    break; // P1 subject assigned 2 blocks, move to next P1
                                } else if (blocksAssignedForP1 === 0) { // If only one block is available, assign it
                                    dailyScheduleEntries.push({
                                        subject: p1Subject.name,
                                        startTime: formatTime(allPotentialSlots[i].startTime),
                                        endTime: formatTime(allPotentialSlots[i].endTime)
                                    });
                                    assignedSlots[i] = true;
                                    blocksAssignedForP1++;
                                    break; // P1 subject assigned 1 block, move to next P1
                                }
                            }
                        }
                    });

                    // 2. Assign Priority 2 Subjects (Alternative Day)
                    eligibleP2ForToday.forEach(p2Subject => {
                        for (let i = 0; i < allPotentialSlots.length; i++) {
                            if (allPotentialSlots[i].type === 'study' && !assignedSlots[i]) {
                                dailyScheduleEntries.push({
                                    subject: p2Subject.name,
                                    startTime: formatTime(allPotentialSlots[i].startTime),
                                    endTime: formatTime(allPotentialSlots[i].endTime)
                                });
                                assignedSlots[i] = true;
                                break; // P2 subject assigned, move to next P2
                            }
                        }
                    });

                    // 3. Assign Priority 3, 4, 5 Subjects
                    // P3 and P4 should be regular (any day, not only weekends). This is handled by iterating all slots.
                    // P5 fills remaining.
                    const p345SubjectsPool = [...p3Subjects, ...p4Subjects, ...p5Subjects];
                    // Shuffle to distribute them more evenly
                    for (let i = p345SubjectsPool.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [p345SubjectsPool[i], p345SubjectsPool[j]] = [p345SubjectsPool[j], p345SubjectsPool[i]];
                    }

                    let currentOtherSubjectIndex = 0;
                    for (let i = 0; i < allPotentialSlots.length; i++) {
                        if (allPotentialSlots[i].type === 'study' && !assignedSlots[i]) {
                            if (p345SubjectsPool.length === 0) break; // No more subjects to schedule

                            const subject = p345SubjectsPool[currentOtherSubjectIndex % p345SubjectsPool.length];
                            dailyScheduleEntries.push({
                                subject: subject.name,
                                startTime: formatTime(allPotentialSlots[i].startTime),
                                endTime: formatTime(allPotentialSlots[i].endTime)
                            });
                            assignedSlots[i] = true;
                            currentOtherSubjectIndex++;
                        }
                    }

                    // Add breaks to the final schedule entries (only if they are part of the potential slots and not overwritten by study)
                    for (let i = 0; i < allPotentialSlots.length; i++) {
                        if (allPotentialSlots[i].type === 'break') {
                            dailyScheduleEntries.push({
                                subject: 'Break',
                                startTime: formatTime(allPotentialSlots[i].startTime), // Keep times for internal sorting
                                endTime: formatTime(allPotentialSlots[i].endTime),     // Keep times for internal sorting
                                isBreak: true // Add a flag to identify breaks for styling
                            });
                        }
                    }

                    // Sort the daily schedule entries by start time for display
                    dailyScheduleEntries.sort((a, b) => parseTime(a.startTime) - parseTime(b.startTime));

                    // Merge consecutive subject entries after sorting
                    dailyScheduleEntries = mergeConsecutiveSubjects(dailyScheduleEntries);
                }

                schedule.push({
                    date: formatDate(currentDay),
                    day: getDayName(currentDay),
                    schedule: dailyScheduleEntries
                });

                // Update p2SkipStatus for the next day's iteration
                p2SkipStatus = nextDayP2SkipStatus;

                currentDay.setDate(currentDay.getDate() + 1); // Move to the next day
            }

            // Store the generated schedule for download
            lastGeneratedSchedule = schedule;

            // --- Display Schedule ---
            scheduleContentDiv.innerHTML = ''; // Clear previous schedule
            if (schedule.length === 0) {
                scheduleContentDiv.innerHTML = '<p class="text-gray-600 text-center">No schedule could be generated for the selected dates/times.</p>';
                downloadScheduleBtn.classList.add('hidden'); // Hide download button if no schedule
            } else {
                schedule.forEach(dayEntry => {
                    const dayDiv = document.createElement('div');
                    dayDiv.className = 'schedule-day';
                    dayDiv.innerHTML = `
                        <h3 class="text-xl font-semibold text-gray-700 mb-3">${dayEntry.day}, ${dayEntry.date}</h3>
                    `;
                    if (dayEntry.schedule.length === 0) {
                        dayDiv.innerHTML += '<p class="text-gray-500">No study blocks scheduled for this day.</p>';
                    } else {
                        dayEntry.schedule.forEach(entry => {
                            const entryDiv = document.createElement('div');
                            // Add 'break' class for styling breaks, and reduced padding
                            entryDiv.className = `schedule-entry ${entry.isBreak ? 'break' : ''}`;
                            entryDiv.innerHTML = `
                                <p class="text-gray-800 font-medium">${entry.subject}</p>
                                ${!entry.isBreak ? `<p class="text-gray-600 text-sm">${entry.startTime} - ${entry.endTime}</p>` : ''}
                            `;
                            dayDiv.appendChild(entryDiv);
                        });
                    }
                    scheduleContentDiv.appendChild(dayDiv);
                });
                downloadScheduleBtn.classList.remove('hidden'); // Show download button if schedule generated
            }

            scheduleOutputDiv.classList.remove('hidden'); // Show the schedule output section
        });

        // Download Schedule button click handler
        downloadScheduleBtn.addEventListener('click', () => {
            if (lastGeneratedSchedule.length === 0) {
                showErrorMessage('No schedule has been generated yet to download.');
                return;
            }

            let tableHtml = `
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <title>Study Schedule</title>
                    <style>
                        @page {
                            size: landscape; /* Set page to landscape mode */
                        }
                        body {
                            font-family: 'Inter', sans-serif;
                            margin: 20px;
                            color: #333;
                        }
                        h1 {
                            text-align: center;
                            color: #4f46e5;
                            margin-bottom: 30px;
                        }
                        table {
                            width: 100%;
                            border-collapse: collapse;
                            margin-bottom: 20px;
                        }
                        th, td {
                            border: 1px solid #ddd;
                            padding: 8px;
                            text-align: left;
                        }
                        th {
                            background-color: #f2f2f2;
                            font-weight: bold;
                        }
                        tr:nth-child(even) {
                            background-color: #f9f9f9;
                        }
                        /* New style for daily tbody to prevent page breaks */
                        .daily-schedule-tbody {
                            page-break-inside: avoid;
                            display: table-row-group; /* Ensure it behaves like a tbody for breaks */
                        }
                        .break-row td { /* Apply to td within break-row */
                            background-color: #fef3c7;
                            color: #92400e;
                            font-weight: normal; /* No bold for breaks */
                            height: 10px; /* Further reduced height for breaks in table */
                            padding-top: 0px; /* Reduced padding */
                            padding-bottom: 0px; /* Reduced padding */
                            line-height: 1; /* Minimize vertical space for text */
                            text-align: center; /* Center "Break" text in table */
                        }
                    </style>
                </head>
                <body>
                    <h1>Study Schedule</h1>
                    <table>
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Day</th>
                                <th>Time</th>
                                <th>Subject</th>
                            </tr>
                        </thead>
            `;

            lastGeneratedSchedule.forEach(dayEntry => {
                // Apply merging logic before generating table rows
                const mergedDailySchedule = mergeConsecutiveSubjects(dayEntry.schedule);

                tableHtml += `<tbody class="daily-schedule-tbody">`; // Start new tbody for each day
                if (mergedDailySchedule.length === 0) {
                    tableHtml += `
                        <tr>
                            <td>${dayEntry.date}</td>
                            <td>${dayEntry.day}</td>
                            <td colspan="2">No study blocks scheduled for this day.</td>
                        </tr>
                    `;
                } else {
                    mergedDailySchedule.forEach((entry, index) => {
                        const rowClass = entry.isBreak ? 'break-row' : '';
                        tableHtml += `
                            <tr class="${rowClass}">
                                ${index === 0 ? `<td rowspan="${mergedDailySchedule.length}">${dayEntry.date}</td>` : ''}
                                ${index === 0 ? `<td rowspan="${mergedDailySchedule.length}">${dayEntry.day}</td>` : ''}
                                <td>${entry.isBreak ? '' : `${entry.startTime} - ${entry.endTime}`}</td>
                                <td>${entry.subject}</td>
                            </tr>
                        `;
                    });
                }
                tableHtml += `</tbody>`; // End tbody for each day
            });

            tableHtml += `
                    </table>
                </body>
                </html>
            `;

            const blob = new Blob([tableHtml], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'study_schedule.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        // Initial render of subjects list
        renderSubjects();

        // Set default dates and times for convenience (optional)
        const today = new Date();
        const nextWeek = new Date();
        nextWeek.setDate(today.getDate() + 7);
        startDateInput.value = formatDate(today);
        endDateInput.value = formatDate(nextWeek);

        // Set default times for weekdays and weekends
        weekdayStartTimeInput.value = '09:00';
        weekdayEndTimeInput.value = '12:00';
        weekendStartTimeInput.value = '10:00';
        weekendEndTimeInput.value = '13:00';
    </script>
</body>
</html>
